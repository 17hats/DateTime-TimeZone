#!/usr/bin/perl -w

use strict;

use lib './lib';

use Data::Dumper;
use DateTime::TimeZone::OlsonDB;
use File::Copy;
use File::Find;
use File::Path;
use File::Spec;
use Getopt::Long;

$Data::Dumper::Indent = 1;
$Data::Dumper::Terse = 1;

my $VERSION = "0.01";

my $INFINITY  = 10 ** 10 ** 10;

my %opts;
GetOptions( 'dir:s' => \$opts{dir},
            'old'   => \$opts{old},
          );

die "Must provide a directory containing Olson DB files\n"
    unless defined $opts{dir} && -d $opts{dir};

my @files = qw( africa antarctica asia australasia
                europe northamerica pacificnew
                southamerica
              );

# need finer control?
push @files, qw( backward etcetera factory systemv )
    if $opts{old};

copy( 'MANIFEST.base', 'MANIFEST' );
open MAN, ">>MANIFEST";

my ( @zones, %categories, @links );
foreach my $f (@files)
{
    my $file = File::Spec->catfile( $opts{dir}, $f );

    die "No such file $file\n" unless -e $file;

    print "Now parsing $file\n";

    my $odb = DateTime::TimeZone::OlsonDB->new;

    $odb->parse_file($file);

    push @links, $odb->links;

    foreach my $zone_name ( $odb->zone_names )
    {
        push @zones, $zone_name;

        my ($category, $name) = split /\//, $zone_name, 2;
        warn "WEIRD ZONE: $zone_name" unless defined $name;
        push @{ $categories{$category} }, $name;

        (my $dir = $category) =~ tr/-/_/;
        (my $clean_name = $name) =~ tr/-/_/;
        $clean_name =~ s/\//::/;

        my $mod_name = "${dir}::$clean_name";

        my $zone = $odb->expanded_zone( name => $zone_name,
                                        expand_to_year => (localtime)[5] + 1910,
                                      );

        my $spans = Dumper zone_as_data($zone);

        $spans =~ s/'inf'/\$DateTime::TimeZone::INFINITY/;
        $spans =~ s/'-inf'/\$DateTime::TimeZone::NEG_INFINITY/;

        $spans =~ s/('(?:start|end)_date'\s+=>\s+)'(\d+)'/$1$2/g;

        my $generator = zone_generator($zone);

        my $body = <<"EOF";
# This file is auto-generated by the Perl DateTime Suite time zone
# code generator ($VERSION) This code generator comes with the
# DateTime::TimeZone module distribution in the tools/ directory
#
# Generated from $file.
#
# Do not edit this file directly.
#
package DateTime::TimeZone::$mod_name;

use strict;

use DateTime::TimeZone;
use DateTime::TimeZone::OlsonDB;

\@DateTime::TimeZone::${mod_name}::ISA = 'DateTime::TimeZone';

my \$spans =
$spans;

sub load
{
    return shift->_init( \@_, spans => \$spans );
}

$generator

1;

__END__

=head1 NAME

DateTime::TimeZone::$mod_name - Time zone data for $zone_name

=head1 DESCRIPTION

This module is an internal timezone definition data file used by
DateTime::TimeZone.  You do not need to use this module directly.

=head1 EXAMPLE

  my \$timezone = DateTime::TimeZone->new( name => '$zone_name' );

=begin testing

  use DateTime::TimeZone;

  ok (my \$zone = DateTime::TimeZone->new(name => '$zone_name'), 'Loaded $zone_name');

=end testing

=cut

EOF

        my @name_pieces = split /\//, $name;
        my $filename = (pop @name_pieces) . '.pm';

        my $outdir = File::Spec->catdir( qw( lib DateTime TimeZone ), $dir, @name_pieces  );

        mkpath( $outdir, 1, 0755 );

        my $outfile = File::Spec->catfile( $outdir, $filename );

        open OUT,">$outfile" or die "Cannot write to $outfile: $!";
        print OUT $body;
        close (OUT);

        print MAN "$outfile\n";
    }
}

my $links = Dumper { @links };
$links =~ s/{/(/;
$links =~ s/}/)/;


my $zones = join "\n", map { "  $_" } sort @zones;
my $cat_names = join "\n", map { "  $_" } sort keys %categories;
my $cat = '';
foreach my $c ( sort keys %categories )
{
    $cat .= "'$c' => [ qw(\n";
    $cat .= join "\n", map { "  $_" } sort @{ $categories{$c} };
    $cat .= "\n) ],\n";
}
my $zonecatalog = <<"EOF";
# This file is auto-generated by the Perl DateTime Suite VTIMEZONE
# parser ($VERSION).
#
# Do not edit this file directly.

package DateTime::TimeZone;

use strict;

\@DateTime::TimeZone::ALL =
qw(
$zones
);

\@DateTime::TimeZone::CATEGORY_NAMES =
qw(
$cat_names
);

\%DateTime::TimeZone::CATEGORIES =
(
$cat
);

\%DateTime::TimeZone::Links =
$links
;

sub All { wantarray ? \@DateTime::TimeZone::ALL : \\\@DateTime::TimeZone::ALL }
sub Categories { wantarray ? \@DateTime::TimeZone::CATEGORY_NAMES : \\\@DateTime::TimeZone::CATEGORY_NAMES }

sub Category
{
    return unless exists \$DateTime::TimeZone::CATEGORIES{ \$_[0] };

    return wantarray ? \@{ \$DateTime::TimeZone::CATEGORIES{ \$_[0] } } : \$DateTime::TimeZone::CATEGORIES{ \$_[0] };
}

1;

__END__

=head1 NAME

DateTime::TimeZoneCatalog - Provides a list of all valid time zone names

=head1 SYNOPSIS

  use DateTime::TimeZoneCatalog;
  # now \@DateTime::TimeZone::CATALOG is populated

  foreach my \$zone ( DateTime::TimeZone->Catalog ) { ... }

=head1 DESCRIPTION

This module contains an enumerated list of all known system timezones,
so that applications can easily present a list of timezones.

=cut

EOF

open OUT2, ">lib/DateTime/TimeZoneCatalog.pm" or die $!;
print OUT2 $zonecatalog;
close OUT2;

sub zone_as_data
{
    my $zone = shift;

    my @spans;

    my @changes = $zone->sorted_changes;

    for ( my $x = 1; $x < @changes; $x++ )
    {
        push @spans,
            DateTime::TimeZone::OlsonDB::Change::two_changes_as_span
                ( @changes[ $x - 1, $x ] );
    }

    unless ( $zone->infinite_rules )
    {
        my $last_observance = $changes[-1]->observance;

        my $utc_end =
            @spans ? $spans[-1]{utc_end} : -1 * $INFINITY;

        push @spans, { utc_start  => $utc_end,
                       utc_end    => $INFINITY,
                       short_name => sprintf( $last_observance->format, '' ),
                       offset     => $last_observance->offset,
                     };
    }

    return \@spans;
}

sub zone_generator
{
    my $zone = shift;

    return '' unless $zone->infinite_rules;

    my $generator = <<'EOF';
my $rules = !RULES;
my $last_observance = !LAST_OBSERVANCE;

sub _generate_spans_until_match
{
    my $self = shift;
    my $dt = shift;

    my @changes;
    foreach my $rule (@$rules)
    {
        my $year = $dt->year;

        my $next = $rule->date_for_year( $year, !OFFSET );

        push @changes,
            DateTime::TimeZone::OlsonDB::Change->new
                ( start_date => $next,
                  short_name =>
                  sprintf( $last_observance->format, $rule->letter ),
                  observance => $last_observance,
                  rule       => $rule,
                );

        next unless $next < $dt;

        $next = $rule->date_for_year( $year + 1, !OFFSET );

        push @changes,
            DateTime::TimeZone::OlsonDB::Change->new
                ( start_date => $next,
                  short_name =>
                  sprintf( $last_observance->format, $rule->letter ),
                  observance => $last_observance,
                  rule       => $rule,
                );
    }

    my @sorted = sort { $a->start_date <=> $b->start_date } @changes;

    my $seconds = $dt->utc_rd_as_seconds;
    my $match;
    for ( my $x = 1; $x < @sorted; $x++ )
    {
        my $span =
            DateTime::TimeZone::OlsonDB::Change::two_changes_as_span
                ( @sorted[ $x - 1, $x ] );

        $self->{tree}->insert( { utc   => [ $span->{utc_start},   $span->{utc_end} ],
                                 local => [ $span->{local_start}, $span->{local_end} ],
                               },
                               $span );

        $match = $span
            if $seconds >= $span->{utc_start} && $seconds < $span->{utc_end};
    }

    return $match;
}
EOF

    my $last_observance = ($zone->sorted_changes)[-1]->observance;

    # This assumes that there is only one observance from end of
    # changes til end of time, which should be guaranteed by code in
    # OlsonDB module.
    my $offset = $last_observance->offset;

    my @rules = $zone->infinite_rules;

    # This is cleaner than making the above a double-quoted string
    $generator =~ s/!RULES/Dumper \@rules/eg;
    $generator =~ s/!LAST_OBSERVANCE/Dumper $last_observance/eg;
    $generator =~ s/!OFFSET/$offset/g;

    return $generator;
}
