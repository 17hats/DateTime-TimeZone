#!/usr/bin/perl -w
#
# Copyright (c) 2003-2005 Dave Rolsky.  All rights reserved.
# Copyright (c)      2005 Daisuke Maki. All rights reserved.
#

use strict;
BEGIN { $ENV{PERL_DATETIME_TIMEZONE_PP} = 1 }
use lib './lib';

use Data::Dumper;
use DateTime::TimeZone::OlsonDB;
use File::Copy;
use File::Find;
use File::Path;
use File::Spec;
use Getopt::Long;
use IO::File;

$Data::Dumper::Indent = 1;
$Data::Dumper::Sortkeys = 1;
$Data::Dumper::Terse = 1;

my $VERSION = "0.08";

my $INFINITY  = 100 ** 100 ** 100;

my %opts;
GetOptions( 'dir:s'     => \$opts{dir},
            'old'       => \$opts{old},
            'file:s'    => \$opts{file},
            'name:s'    => \$opts{name},
            'version:s' => \$opts{version},
            'help'      => \$opts{help},
          );

$opts{help} = 1
    unless defined $opts{dir} && -d $opts{dir};

$opts{help} = 1
    unless defined $opts{version} || $opts{file} || $opts{name};

if ( $opts{help} )
{
    print <<'EOF';

This script parses the Olson time zone database files and turns them
into a set of Perl modules.  It also generates the MANIFEST and the
DateTime::TimeZoneCatalog module, which contains a list of all the
available time zone names.

By default, it looks for files named africa, antarctica, asia,
australasia, europe, northamerica, pacificnew, southamerica, and
backward.  All other files are ignored.

It takes the following arguments:

  --dir      A directory containing Olson db files.

  --version  The version of the Olson data files being used.
             Required unless one of the debugging options is given.

  --file     Parse just the file with the given name.  For debugging.

  --name     Only create the specified time zone.  For debugging.

  --old      Also look for files named etcetera, factory, and systemv

  --help     What you are reading

If the --file or --name options are specified, the MANIFEST and
DateTime::TimeZoneCatalog files will not be generated.

EOF

    exit;
}

my @files;

if ( $opts{file} )
{
    @files = $opts{file};
}
else
{
    @files = qw( africa antarctica asia australasia
                 europe northamerica pacificnew
                 southamerica backward
               );

    push @files, qw( etcetera factory systemv )
        if $opts{old};
}

unless ( $opts{name} || $opts{file} )
{
    copy( 'MANIFEST.base', 'MANIFEST' );
    open MAN, ">>MANIFEST" or die "Cannot write to MANIFEST: $!";
}

my ( @zones, %categories, %links );

foreach my $f ( sort @files )
{
    my $file = File::Spec->catfile( $opts{dir}, $f );

    die "No such file $file\n" unless -e $file;

    print "Now parsing $file\n";

    my $odb = DateTime::TimeZone::OlsonDB->new;

    $odb->parse_file($file);

    %links = ( %links, $odb->links );

    foreach my $zone_name ( sort $odb->zone_names )
    {
        if ( $opts{name} )
        {
            next unless $zone_name eq $opts{name};
        }
        print "  creating zone $zone_name\n";

        push @zones, $zone_name;

        my ($category, $name) = split /\//, $zone_name, 2;
        push @{ $categories{$category} }, $name;

        (my $dir = $category) =~ tr/-/_/;
        (my $outfile1 = $name) =~ tr/-/_/;

        (my $mod_name = $zone_name) =~ s/\//::/g;
        $mod_name =~ tr/-/_/;

        my $max_year = (localtime)[5] + 1910;
        my $zone = $odb->expanded_zone( name => $zone_name,
                                        expand_to_year => $max_year,
                                      );

        my $from = "Generated from $file.";
        $from .= "  Olson data version $opts{version}"
            if defined $opts{version};

        my $pm_body = generate_pm($mod_name, $zone, $max_year, $from);
        my $pp_body = generate_pp($mod_name, $zone, $max_year, $from);
        my $xs_body = generate_xs($mod_name, $zone, $max_year, $from, $zone_name);

        my @name_pieces   = split /\//, $outfile1;
        my $base_filename = pop @name_pieces;
        my $pm_filename   = $base_filename . '.pm';
        my $pp_filename   = $base_filename . 'PP.pm';
        my $xs_filename   = $base_filename . '.xs';

        my $outdir = File::Spec->catdir( qw( lib DateTime TimeZone ),
                                         $dir, @name_pieces  );

        mkpath( $outdir, 1, 0755 );

        # Write to .pm
        my $pm_outfile = File::Spec->catfile( $outdir, $pm_filename );
        open OUT,">$pm_outfile" or die "Cannot write to $pm_outfile: $!";
        print OUT $pm_body or die "Cannot write to $pm_outfile: $!";
        close (OUT) or die "Cannot write to $pm_outfile: $!";

        # Write pure-perl .pm
        my $pp_outfile = File::Spec->catfile( $outdir, $pp_filename );
        open OUT,">$pp_outfile" or die "Cannot write to $pp_outfile: $!";
        print OUT $pp_body or die "Cannot write to $pp_outfile: $!";
        close (OUT) or die "Cannot write to $pp_outfile: $!";

        # Write to .xs
        my $xs_outfile = File::Spec->catfile( $outdir, $xs_filename );
        open OUT,">$xs_outfile" or die "Cannot write to $xs_outfile: $!";
        print OUT $xs_body or die "Cannot write to $xs_outfile: $!";
        close (OUT) or die "Cannot write to $xs_outfile: $!";

        unless ( $opts{name} || $opts{file} )
        {
            print MAN "$pm_outfile\n" or die "Cannot write to MANIFEST: $!";
            print MAN "$xs_outfile\n" or die "Cannot write to MANIFEST: $!";
            print MAN "$pp_outfile\n" or die "Cannot write to MANIFEST: $!";
        }
    }
}

exit if $opts{name};

# override some links and add others
%links =
    ( %links,
      'Etc/GMT+0'   => 'UTC',
      'Etc/Universal' => 'UTC',
      'Etc/Zulu'    => 'UTC',
      'Etc/UCT'     => 'UTC',
      'GMT0'        => 'UTC',
      'GMT'         => 'UTC',
    );

delete $links{UTC};

# This links to America/Indiana in the "backward" file
delete $links{EST};
# And this one is for America/Phoenix
delete $links{MST};

my $links = Dumper \%links;
$links =~ s/{/(/;
$links =~ s/}/)/;

my $zones = join "\n", map { "  $_" } sort @zones;
my $cat_names = join "\n", map { "  $_" } sort keys %categories;
my $cat = '';
foreach my $c ( sort keys %categories )
{
    $cat .= "'$c' => [ qw(\n";
    $cat .= join "\n", map { "  $_" } sort @{ $categories{$c} };
    $cat .= "\n) ],\n";
}
my $zonecatalog = <<"EOF";
# This file is auto-generated by the Perl DateTime Suite VTIMEZONE
# parser ($VERSION).
#
# Do not edit this file directly.

package DateTime::TimeZone;

use strict;

\@DateTime::TimeZone::ALL =
qw(
$zones
);

\@DateTime::TimeZone::CATEGORY_NAMES =
qw(
$cat_names
);

\%DateTime::TimeZone::CATEGORIES =
(
$cat
);

\%DateTime::TimeZone::LINKS =
$links
;

sub all_names { wantarray ? \@DateTime::TimeZone::ALL : \\\@DateTime::TimeZone::ALL }
sub categories { wantarray ? \@DateTime::TimeZone::CATEGORY_NAMES : \\\@DateTime::TimeZone::CATEGORY_NAMES }
sub links { wantarray ? %DateTime::TimeZone::LINKS : \\%DateTime::TimeZone::LINKS }

sub names_in_category
{
    return unless exists \$DateTime::TimeZone::CATEGORIES{ \$_[0] };

    return wantarray ? \@{ \$DateTime::TimeZone::CATEGORIES{ \$_[0] } } : \$DateTime::TimeZone::CATEGORIES{ \$_[0] };
}

1;

__END__

=head1 NAME

DateTime::TimeZoneCatalog - Provides a list of all valid time zone names

=head1 SYNOPSIS

See DateTime::TimeZone for usage details.

=head1 DESCRIPTION

This module contains an enumerated list of all known system timezones,
so that applications can easily present a list of timezones.

=cut

EOF

open OUT2, ">lib/DateTime/TimeZoneCatalog.pm" or die $!;
print OUT2 $zonecatalog or die $!;
close OUT2 or die $!;

sub generate_pm
{
    my($mod_name, $zone, $max_year, $from) = @_;
    my $spans = serialize_spans(zone_as_spans($zone));

    $spans =~ s/-inf/&DateTime::TimeZone::NEG_INFINITY/g;
    $spans =~ s/inf/&DateTime::TimeZone::INFINITY/g;

    $spans =~ s/('(?:start|end)_date'\s+=>\s+)'(\d+)'/$1$2/g;

    my $generator = pm_zone_generator($zone);

    return <<"EOF";
# This file is auto-generated by the Perl DateTime Suite time zone
# code generator ($VERSION) This code generator comes with the
# DateTime::TimeZone module distribution in the tools/ directory
#
# $from
#
# Do not edit this file directly.
#
package DateTime::TimeZone::$mod_name;

use strict;

use DateTime::TimeZone::Singleton;
use DateTime::TimeZone::OlsonDB;

\@DateTime::TimeZone::${mod_name}::ISA = ( 'DateTime::TimeZone::Singleton' );

BEGIN { 
    if (! DateTime::TimeZone::LOADED_XS()) {
        require DateTime::TimeZone::${mod_name}PP;
    } else {
        if (\$] > 5.006) {
            require XSLoader;
            XSLoader::load('DateTime::TimeZone::${mod_name}');
        } else {
            require DynaLoader;
            push \@DateTime::TimeZone::${mod_name}::ISA, 'DynaLoader';
            DateTime::TimeZone::${mod_name}->bootstrap();
        }
    }
}

$generator

1;

EOF
}

sub generate_pp
{
    my($mod_name, $zone, $max_year, $from) = @_;

    my $pp_generator = pp_zone_generator($zone);
    my $spans = serialize_spans(zone_as_spans($zone));

    $spans =~ s/-inf/DateTime::TimeZone::NEG_INFINITY/g;
    $spans =~ s/inf/DateTime::TimeZone::INFINITY/g;

    $spans =~ s/('(?:start|end)_date'\s+=>\s+)'(\d+)'/$1$2/g;

    return <<"EOF";
# This file is auto-generated by the Perl DateTime Suite time zone
# code generator ($VERSION) This code generator comes with the
# DateTime::TimeZone module distribution in the tools/ directory
#
# $from
#
# Do not edit this file directly.
#
package DateTime::TimeZone::$mod_name;

use strict;

my \$spans =
$spans;

sub _spans { \$spans }
sub max_span { \$spans->[-1] }
sub max_year { $max_year }
sub push_span { shift; push @\$spans, shift }

$pp_generator

1;

EOF
}


sub generate_xs
{
    my($mod_name, $zone, $max_year, $from, $zone_name) = @_;

    (my $xs_name_space = lc $zone_name) =~ s/[\/-]/_/g;
    $xs_name_space =~ s/^/__/;

    my $xs_bootstrap = xs_bootstrap_code($xs_name_space, $zone, $max_year);

    $xs_bootstrap =~ s/-inf\.0/NEG_INFINITY/g;
    $xs_bootstrap =~ s/inf\.0/INFINITY/g;
    my $xs_body = <<"EOF";
/********************************************************************
 *
 * DateTime::TimeZone::${mod_name}
 *
 * This file is auto-generated by the Perl Datetime suite time zone
 * code generator ($VERSION) This code generateor comes with the 
 * DateTime::TimeZone module distribution in the tools/ directory
 *
 * $from
 *
 * Do no edit this file directly.
 *
 ********************************************************************/

#include "EXTERN.h"
#include "perl.h"
#include "XSUB.h"
#include "ppport.h"
#define NEED_allocTIMEZONE
#include "timezone.h"

MODULE = DateTime::TimeZone::$mod_name   PACKAGE = DateTime::TimeZone::$mod_name

PROTOTYPES: ENABLE

$xs_bootstrap

EOF

}

sub zone_as_spans
{
    my $zone = shift;

    my @spans;

    my @changes = $zone->sorted_changes;

    for ( my $x = 1; $x < @changes; $x++ )
    {
        my $last_total_offset = $x > 1 ? $changes[ $x - 2 ]->total_offset : undef;

        my $span =
            DateTime::TimeZone::OlsonDB::Change::two_changes_as_span
                ( @changes[ $x - 1, $x ], $last_total_offset );

        push @spans, $span;

        if (@spans > 2)
        {
            die "Gap in UTC end/start datetime for " . $zone->name
                unless $spans[-2]{utc_end} == $spans[-1]{utc_start};
        }
    }

    unless ( $zone->infinite_rules )
    {
        my $last_observance = $changes[-1]->observance;

        my $utc_start =
            @spans ? $spans[-1]{utc_end} : -1 * $INFINITY;

        push @spans, { utc_start   => $utc_start,
                       utc_end     => $INFINITY,
                       local_start => $utc_start - $last_observance->total_offset,
                       local_end   => $INFINITY,
                       short_name  => sprintf( $last_observance->format, '' ),
                       offset      => $last_observance->total_offset,
                       is_dst      => 0,
                     };
    }

    return \@spans;
}

sub serialize_spans
{
    my $spans = shift;

    my $string = "[\n";
    $string .= join "\n", map { serialize_span($_) } @$spans;
    $string .= "\n]";

    return $string;
}

sub serialize_span
{
    my $span = shift;
    # must correspond to constants in DT::TZ, and short_name is always last
    my @keys = qw( utc_start utc_end local_start local_end offset is_dst );
    my $string = "    [\n";
    $string .= join ",\n", @$span{@keys};
    $string .= ",\n'$span->{short_name}'";
    $string .= "\n    ],";

    return $string;
}

sub xs_bootstrap_code
{
    my $xs_name_space = shift;
    my $zone = shift;
    my $max_year = shift;

    my $spans = zone_as_spans($zone);
    my $last_observance = ($zone->sorted_changes)[-1]->observance;
    # This assumes that there is only one observance from end of
    # changes til end of time, which should be guaranteed by code in
    # OlsonDB module.
    my $offset = $last_observance->total_offset;

    my $string = sprintf(<<EOF, scalar(@$spans), $max_year, $offset);
SV *
_init(class, psv)
        SV *class;
        SV *psv;
    PREINIT:
        dtz_span *span;
        SV *sv;
        allocTIMEZONE_PREP;
    CODE:
        allocTIMEZONE(sv, class, psv);

        state = XS_STATE(sv);
        state->spanset_size  = %d;
        state->spanset_count = newSViv(state->spanset_size);
        state->max_year      = newSViv(%d);
        state->last_offset   = newSViv(%d);
        Newz(1234, state->spanset, state->spanset_size, dtz_span *);
EOF

    my $idx = 0;
    foreach my $span (@$spans) {
        my $short_name_len = length($span->{short_name});
        $string .= <<"        EOF";
        INIT_SPAN(span, $span->{utc_start}.0, $span->{utc_end}.0, $span->{local_start}.0, $span->{local_end}.0, $span->{offset}, $span->{is_dst}, "$span->{short_name}", $short_name_len);
        state->spanset[$idx] = span;

        EOF
        $idx++;
    }
    $string .= <<EOF;
        RETVAL = sv;
    OUTPUT:
        RETVAL
EOF

    return $string;
}

sub pp_zone_generator
{
    my $zone = shift;

    return '' unless $zone->infinite_rules;

    my $generator = <<'EOF';
sub last_offset { !OFFSET }
EOF

    my $last_observance = ($zone->sorted_changes)[-1]->observance;

    # This assumes that there is only one observance from end of
    # changes til end of time, which should be guaranteed by code in
    # OlsonDB module.
    my $offset = $last_observance->total_offset;
    $generator =~ s/!OFFSET/$offset/g;

    return $generator;
}

sub pm_zone_generator
{
    my $zone = shift;

    return '' unless $zone->infinite_rules;

    my $generator = <<'EOF';
my $last_observance = !LAST_OBSERVANCE;
sub last_observance { $last_observance }

my $rules = !RULES;
sub rules { $rules }
EOF

    my $last_observance = ($zone->sorted_changes)[-1]->observance;

    # hack to trim size of dumped object
    delete $last_observance->{utc_start_datetime}{locale};
    delete $last_observance->{local_start_datetime}{locale};
    delete $last_observance->{utc_start_datetime}{local_c};
    delete $last_observance->{local_start_datetime}{local_c};
    delete $last_observance->{rules};
    delete $last_observance->{first_rule};

    # This assumes that there is only one observance from end of
    # changes til end of time, which should be guaranteed by code in
    # OlsonDB module.
    my $offset = $last_observance->total_offset;

    my @rules = $zone->infinite_rules;

    # This is cleaner than making the above a double-quoted string
    $generator =~ s/!RULES/
        my $string .= "[\n";
        foreach my $r (@rules) {
            $string .= "  DateTime::TimeZone::OlsonDB::Rule->new(\n";
            $string .= join(",\n",
                map { "    $_ => " . 
                    (defined($r->$_()) ?
                        "'" . $r->$_() . "'" :
                        "undef")
                } qw(at from in letter name on save to type)
            );
            $string .= "\n  ),\n";
        }
        $string .= "]\n";
        $string;
    /egx;
    $generator =~ s/!LAST_OBSERVANCE/Dumper $last_observance/eg;
    $generator =~
        s/\$VAR1->{'local_start_datetime'}{'tz'}/bless( {
      'name' => 'floating',
      'offset' => 0
    }, 'DateTime::TimeZone::Floating' )/;
    $generator =~
        s/\$VAR1->{'utc_start_datetime'}{'tz'}/bless( {
      'name' => 'floating',
      'offset' => 0
    }, 'DateTime::TimeZone::Floating' )/;
    $generator =~ s/!OFFSET/$offset/g;
    $generator =~ s/!OFFSET/$offset/g;

    return $generator;
}
