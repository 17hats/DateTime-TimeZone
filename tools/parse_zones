#!/usr/bin/perl -w

use strict;
use Data::Dumper;
use File::Copy;
use File::Find;
use File::Path;
use File::Spec;
use XML::Simple;

my $VERSION = "0.03";

$Data::Dumper::Indent = 1;
$Data::Dumper::Terse = 1;

my $indir = shift;
my @files;
find( { wanted => \&find_ics_files,
        no_chdir => 1,
      },
      $indir );

sub find_ics_files { push @files, $_ if /\.ics$/ }

copy( 'MANIFEST.base', 'MANIFEST' );
open MAN, ">>MANIFEST";

my %categories;
my @zones;
foreach my $infile (@files)
{
    print "Now parsing $infile\n";

    $infile =~ m,[\\/]([^\\/]+)[\\/]([^\\/]+).ics$,
        or die "Couldn't parse out a directory for $infile\n";

    my $dir = $1;
    my $zone = $2;

    push @{ $categories{$1} }, $2;

    push @zones, "$dir/$zone";

    $zone =~ tr/-/_/;

    my $outdir = "lib/DateTime/TimeZone/$dir";
    mkpath( $outdir, 1, 0755 );

    my $modname = "${dir}::$zone";

    open IN, "<$infile" or die $!;
    my @lines = <IN>;
    close IN;

    # Convert VCALENDAR files to simplified XML, so we can parse  them with XML::Simple
    map { s/^BEGIN:(.*)$/<$1>/ ||
          s/^END:(.*)$/<\/$1>/ ||
          s/^(.*?):(.*)$/<$1>$2<\/$1>/ } @lines;

    my $ref = XMLin( (join '', @lines),
                     # force these elements to be represented as
                     # arrays, no matter how many elements they
                     # contain
                     forcearray => [ 'RDATE', 'STANDARD', 'DAYLIGHT' ],
                   );

    # These are the important bits for getting offsets
    my $core = { STANDARD => $ref->{VTIMEZONE}{STANDARD},
                 DAYLIGHT => $ref->{VTIMEZONE}{DAYLIGHT},
               };

    my $zone_info = Dumper( $core );

    my $url = $ref->{VTIMEZONE}{TZURL} ? '\Q$ref->{TZURL}\E' : '';

    my $body = <<"EOF";
# This file is auto-generated by the Perl DateTime Suite VTIMEZONE
# parser ($VERSION)
#
# Generated from $infile.
#
# Do not edit this file directly.

package DateTime::TimeZone::$modname;

use strict;

\@DateTime::TimeZone::${modname}::ISA = 'DateTime::TimeZone';

sub new
{
    return \$_[0]->_init( zone_info =>
$zone_info
                        );
}

sub full_name { '\Q$dir/$zone\E' }
sub category  { '$dir' }
sub zone_name { '$zone' }
sub id  { '\Q$ref->{VTIMEZONE}{TZID}\E' }
sub url { $url }
sub version { $ref->{VERSION} }

1;

__END__

=head1 NAME

DateTime::TimeZone::$modname - Time zone data for $dir/$zone

=head1 DESCRIPTION

This module is an internal timezone definition data file used by
DateTime::TimeZone.  You do not need to use this module directly.

=head1 EXAMPLE

  my \$timezone = DateTime::TimeZone->new( name => '$dir/$zone' );

=begin testing

use DateTime::TimeZone;

ok (my \$zone = DateTime::TimeZone->new(name => '$dir/$zone'), 'Loaded $dir/$zone');

my \$tzid;
ok(\$tzid = \$zone->tzid, 'Got a tzid for $dir/$zone');
\$tzid =~ s\/-\/_\/g; # can not have - in module names.
                  #gotta match those
ok(\$tzid =~ '$dir\/$zone\$',   'TZID matches zonename');

=end testing

=cut
EOF

    my $file = File::Spec->catfile( $outdir, "$zone.pm" );

    open OUT,">$file" or die $!;
    print OUT $body;
    close (OUT);

    print MAN "$file\n";
}

my $zones = join "\n", map { "  $_" } sort @zones;
my $cat_names = join "\n", map { "  $_" } sort keys %categories;
my $cat = '';
foreach my $c ( sort keys %categories )
{
    $cat .= "'\Q$c\E' => [ qw(\n";
    $cat .= join "\n", map { "  $_" } sort @{ $categories{$c} };
    $cat .= "\n) ],\n";
}
my $zonecatalog = <<"EOF";
# This file is auto-generated by the Perl DateTime Suite VTIMEZONE
# parser ($VERSION).
#
# Do not edit this file directly.

package DateTime::TimeZone;

use strict;

\@DateTime::TimeZone::ALL =
qw(
$zones
);

\@DateTime::TimeZone::CATEGORY_NAMES =
qw(
$cat_names
);

\%DateTime::TimeZone::CATEGORIES =
(
$cat
);

sub All { wantarray ? \@DateTime::TimeZone::ALL : \\\@DateTime::TimeZone::ALL }
sub Categories { wantarray ? \@DateTime::TimeZone::CATEGORY_NAMES : \\\@DateTime::TimeZone::CATEGORY_NAMES }

sub Category
{
    return unless exists \$DateTime::TimeZone::CATEGORIES{ \$_[0] };

    return wantarray ? \@{ \$DateTime::TimeZone::CATEGORIES{ \$_[0] } } : \$DateTime::TimeZone::CATEGORIES{ \$_[0] };
}

1;

__END__

=head1 NAME

DateTime::TimeZoneCatalog - Provides a list of all valid time zone names

=head1 SYNOPSIS

  use DateTime::TimeZoneCatalog;
  # now \@DateTime::TimeZone::CATALOG is populated

  foreach my \$zone ( DateTime::TimeZone->Catalog ) { ... }

=head1 DESCRIPTION

This module contains an enumerated list of all known system timezones,
so that applications can easily present a list of timezones.

=cut


EOF

open OUT2, ">lib/DateTime/TimeZoneCatalog.pm" or die $!;
print OUT2 $zonecatalog;
close OUT2;

